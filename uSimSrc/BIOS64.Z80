	TITLE	"uSim 64K CP/M-IN-ROM BIOS -- Z80 VERSION"

; BIOS64.Z80 - uSim 64K CP/M BIOS
; Copyright (C) 2000  Tsurishaddai Williamson, tsuri@earthlink.net
;
; This program is free software; you can redistribute it and/or
; modify it under the terms of the GNU General Public License
; as published by the Free Software Foundation; either version 2
; of the License, or (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program; if not, write to the Free Software
; Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

; NOTE: This must assemble to the same object as BIOS64.ASM.

	.Z80

; 63.5K CP/M LOCATIONS
MEMSIZ	EQU	64			; MEMORY SIZE, KILOBYTES
CPMVER	EQU	22			; CP/M VERSION
CCP	EQU	3200H+(MEMSIZ-20)*1024	; CCP BASE ADDRESS
BDOS	EQU	CCP+0800H		; BDOS BASE ADDRESS
BIOS	EQU	CCP+1600H		; BIOS BASE ADDRESS
DATA	EQU	BIOS+(2300H-1F80H)	; BIOS UNINITIALIZED DATA ADDRESS
REBOOT	EQU	0000H			; "JP REBOOT" TO REBOOT
IOBYTE	EQU	0003H			; ADDRESS OF I/O BYTE VARIABLE
USRDSK	EQU	0004H			; ADDRESS OF USER NUMBER / CURRENT VARIABLE
SYSTEM	EQU	0005H			; "CALL SYSTEM" FOR SYSTEM CALL
USRFCB	EQU	005CH			; ADDRESS OF DEFAULT FILE CONTROL BLOCK
USRBUF	EQU	0080H			; ADDRESS OF DEFAULT I/O BUFFER
USRTPA	EQU	0100H			; ADDRESS OF TRANSIANT PROGRAM AREA

	.SOURCE	"SYSTEM.EQU"

	ORG	BIOS

; JUMP TABLE OF BIOS FUNCTIONS
	JP	CBOOT	; 0  -- COLD BOOT
WBOOTE:	JP	WBOOT	; 1  -- WARM BOOT
	JP	CONIST	; 2  -- CONSOLE INPUT STATUS
	JP	CONIN	; 3  -- CONSOLE INPUT
	JP	CONOUT	; 4  -- CONSOLE OUTPUT
	JP	LSTOUT	; 5  -- LIST OUTPUT
	JP	PUNOUT	; 6  -- PUNCH OUTPUT
	JP	RDRIN	; 7  -- READER INPUT
	JP	HOMTRK	; 8  -- HOME DISK
	JP	SELDSK	; 9  -- SELECT DISK
	JP	SETTRK	; 10 -- SET TRACK NUMBER
	JP	SETSEC	; 11 -- SET SECTOR NUMBER
	JP	SETDMA	; 12 -- SET DMA ADDRESS
	JP	RDSEC	; 13 -- READ DISK SECTOR
	JP	WRSEC	; 14 -- WRITE DISK SECTOR
	JP	LSTOST	; 15 -- LIST OUTPUT STATUS
	JP	SECXLT	; 16 -- TRANSLATE SECTOR NUMBER
; EXTRA FUNCTIONS FOR USIM
	JP	OPNFIL	; 17 -- OPEN HOST FILE
	JP	CLSFIL	; 18 -- COSE HOST FILE
	JP	DELFIL	; 19 -- DELETE HOST FILE
	JP	MAKFIL	; 20 -- MAKE HOST FILE
	JP	RDFIL	; 21 -- READ HOST FILE
	JP	WRFIL	; 22 -- WRITE HOST FILE
	JP	RDTIM	; 23 -- READ TIME OF DAY

; COLD BOOT BANNER DISPLAYS MEMORY SIZE AND CP/M VERSION
BANNER:	DB	13,10
	DB	MEMSIZ / 10 + '0'
	DB	MEMSIZ MOD 10 + '0'
	DB	'K CP/M vers '
	DB	CPMVER / 10 + '0'
	DB	'.'
	DB	CPMVER MOD 10 + '0'
	DB	13,10
	DB	0

; BIOS COLD BOOT FUNCTION
CBOOT:	LD	SP,STACK
	; SET IOBYTE: LST=LPT, PUN=PTP, RDR=PTR, CON=TTY
	LD	A,10010100B
	LD	(IOBYTE),A
	; SET CURRENT USER=0 AND DISK=A
	XOR	A
	LD	(USRDSK),A
	; DISPLAY BOOT BANNER
	LD	BC,BANNER
	CALL	PUTS
	; CCP AND BDOS ARE IN PLACE
GOCPM:	; ERROR IF FIRST INSTRUCTION OF CCP IS NOT "JP"
	LD	A,(CCP)
	CP	0C3H
	JP	NZ,ERROR
	; ERROR IF FIRST INSTRUCTION OF BDOS IS NOT "JP"
	LD	A,(BDOS+6)
	CP	0C3H
	JP	NZ,ERROR
	; PREPARE DEFAULT DMA POINTER
	LD	BC,USRBUF
	CALL	SETDMA
	; PREPARE "REBOOT: JP WBOOTE"
	; PREPARE "SYSTEM: JP BDOS+6"
	LD	A,0C3H
	LD	(REBOOT),A
	LD	(SYSTEM),A
	LD	HL,WBOOTE
	LD	(REBOOT+1),HL
	LD	HL,BDOS+6
	LD	(SYSTEM+1),HL
	; CCP IN: C = USRDSK
	LD	A,(USRDSK)
	LD	C,A
	; ENABLE INTERRUPTS AND ENTER CCP
	EI
	JP	CCP

; RETRY THE WARM BOOT IF THERE WAS AN ERROR
ERRMSG:	DB	13,10,'?SYSTEM',13,10,0
ERROR:	LD	BC,ERRMSG
	CALL	PUTS
	CALL	CONIN

; BIOS WARM BOOT FUNCTION
WBOOT:	LD	SP,STACK
	; COPY CCP+BDOS INTO MEMORY
	XOR	A
	LD	(CCP),A
	LD	(BDOS+6),A
	; LOAD FROM ROM
	LD	A, MINROM + 3
	OUT	(BANK0),A
	LD	BC,CCP - (BNKSIZ * 3)
	LD	DE,CCP
COPY:	LD	A,(BC)
	LD	(DE),A
	INC	BC
	INC	DE
	LD	A,D
	OR	E
	JP	NZ,COPY
	LD	A,MINRAM
	OUT	(BANK0),A
	; ENTER CP/M
	JP	GOCPM

; PRINT A STRING
; IN: BC = ADDRESS OF ZERO-TERMINATED STRING
PUTS:	LD	A,DEVTTY
	OUT	(DEVCTL),A
	LD	A,(BC)
	OR	A
	RET	Z
	INC	BC
	OUT	(DEVDAT),A
	JP	PUTS

; LOGICAL CON: DEVICE INPUT STATUS VIA IOBYTE
CONIST:	LD	A,(IOBYTE)
        AND	00000011B
        JP	Z,TTYIST
        CP	00000001B
        JP	Z,CRTIST
        CP	00000010B
        JP	Z,RDRIST

; PHYSICAL UC1: DEVICE INPUT STATUS
UC1IST:	LD	A,DEVUC1
	JP	DEVIST

; LOGICAL CON: DEVICE INPUT VIA IOBYTE
CONIN:	CAll	CONIST
	JP	Z,CONIN
	LD	A,(IOBYTE)
        AND	00000011B
        JP	Z,TTYIN
        CP	00000001B
        JP	Z,CRTIN
        CP	00000010B
        JP	Z,RDRIN

; PHYSICAL UC1: DEVICE INPUT
UC1IN:	LD	A,DEVUC1
	JP	DEVIN

; LOGICAL CON: DEVICE OUTPUT STATUS VIA IOBYTE
CONOST: LD	A,(IOBYTE)
        AND	00000011B
        JP	Z,TTYOST
        CP	00000001B
        JP	Z,CRTOST
        CP	00000010B
        JP	Z,LPTOST

; PHYSICAL UC1: DEVICE OUTPUT STATUS
UC1OST:	LD	A,DEVUC1
	JP	DEVOST

; LOGICAL CON: DEVICE OUTPUT VIA IOBYTE
CONOUT:	CALL	CONOST
	JP	Z,CONOUT
	LD	A,(IOBYTE)
        AND	00000011B
        JP	Z,TTYOUT
        CP	00000001B
        JP	Z,CRTOUT
        CP	00000010B
        JP	Z,LPTOUT

; PHYSICAL UC1: DEVICE OUTPUT
UC1OUT:	LD	A,DEVUC1
	JP	DEVOUT

; LOGICAL LST: DEVICE OUTPUT VIA IOBYTE
LSTOUT:	CALL	LSTOST
	JP	Z,LSTOUT
	LD	A,(IOBYTE)
        AND	11000000B
        JP	Z,TTYOUT
        CP	01000000B
        JP	Z,CRTOUT
        CP	10000000B
        JP	Z,LPTOUT

; PHYSICAL UL1: DEVICE OUTPUT
UL1OUT:	LD	A,DEVUL1
	JP	DEVOUT

; LOGICAL LST: DEVICE OUTPUT STATUS VIA IOBYTE
LSTOST:	LD	A,(IOBYTE)
        AND	11000000B
        JP	Z,TTYOST
        CP	01000000B
        JP	Z,CRTOST
        CP	10000000B
        JP	Z,LPTOST

; PHYSICAL UL1: DEVICE OUTPUT STATUS
UL1OST:	LD	A,DEVUL1
	JP	DEVOST

; LOGICAL PUN: DEVICE OUTPUT STATUS VIA IOBYTE
PUNOST:	LD	A,(IOBYTE)
        AND	00110000B
        JP	Z,TTYOST
        CP	00010000B
        JP	Z,PTPOST
        CP	00100000B
        JP	Z,UP1OST

; PHYSICAL UP2: DEVICE OUTPUT STATUS
UP2OST:	LD	A,DEVUP2
	JP	DEVOST

; LOGICAL PUN: DEVICE OUTPUT VIA IOBYTE
PUNOUT:	CALL	PUNOST
	JP	Z,PUNOUT
	LD	A,(IOBYTE)
        AND	00110000B
        JP	Z,TTYOUT
        CP	00010000B
        JP	Z,PTPOUT
        CP	00100000B
        JP	Z,UP1OUT

; PHYSICAL UP2: DEVICE OUTPUT
UP2OUT:	LD	A,DEVUP2
	JP	DEVOUT

; LOGICAL RDR: DEVICE INPUT STATUS VIA IOBYTE
RDRIST:	LD	A,(IOBYTE)
        AND	00001100B
        JP	Z,TTYIST
        CP	00000100B
        JP	Z,PTRIST
        CP	00001000B
        JP	Z,UR1IST

; PHYSICAL UR2: DEVICE INPUT STATUS
UR2IST:	LD	A,DEVUR2
	JP	DEVIST

; LOGICAL RDR: DEVICE INPUT VIA IOBYTE
RDRIN:	CALL	RDRIST
	JP	Z,RDRIN
	LD	A,(IOBYTE)
        AND	00001100B
        JP	Z,TTYIN
        CP	00000100B
        JP	Z,PTRIN
        CP	00001000B
        JP	Z,UR1IN

; PHYSICAL UR2: DEVICE INPUT
UR2IN:	LD	A,DEVUR2
	JP	DEVIN

; PHYSICAL TTY: DEVICE INPUT STATUS
TTYIST:	LD	A,DEVTTY

; CHARACTER DEVICE INPUT STATUS
DEVIST:	OUT	(DEVCTL),A
	IN	A,(DEVCTL)
	AND	DEVRD

; RETURN STATUS -1 IF READY, 0 IF NOT
RETST:	OR	A
	RET	Z
	LD	A,255
	RET

; PHYSICAL TTY: DEVICE INPUT
TTYIN:	LD	A,DEVTTY

; CHARACTER DEVICE INPUT
DEVIN:	OUT	(DEVCTL),A
	IN	A,(DEVDAT)
	RET

; PHYSICAL TTY: DEVICE OUTPUT STATUS
TTYOST:	LD	A,DEVTTY

; CHARACTER DEVICE OUTPUT STATUS
DEVOST:	OUT	(DEVCTL),A
	IN	A,(DEVCTL)
	AND	DEVWR
	JP	RETST

; PHYSICAL TTY: DEVICE OUTPUT
TTYOUT:	LD	A,DEVTTY

; CHARACTER DEVICE OUTPUT
DEVOUT:	OUT	(DEVCTL),A
	LD	A,C
	OUT	(DEVDAT),A
	RET

; PHYSICAL CRT: DEVICE INPUT STATUS
CRTIST:	LD	A,DEVCRT
	JP	DEVIST

; PHYSICAL CRT: DEVICE INPUT
CRTIN:	LD	A,DEVCRT
	JP	DEVIN

; PHYSICAL CRT: DEVICE OUTPUT STATUS
CRTOST:	LD	A,DEVCRT
	JP	DEVOST

; PHYSICAL CRT: DEVICE OUTPUT
CRTOUT:	LD	A,DEVCRT
	JP	DEVOUT

; PHYSICAL LPT: DEVICE OUTPUT STATUS
LPTOST:	LD	A,DEVLPT
	JP	DEVOST

; PHYSICAL LPT: DEVICE OUTPUT
LPTOUT:	LD	A,DEVLPT
	JP	DEVOUT

; PHYSICAL PTP: DEVICE OUTPUT STATUS
PTPOST:	LD	A,DEVPTP
	JP	DEVOST

; PHYSICAL PTP: DEVICE OUTPUT
PTPOUT:	LD	A,DEVPTP
	JP	DEVOUT

; PHYSICAL UP1: DEVICE OUTPUT STATUS
UP1OST:	LD	A,DEVUP1
	JP	DEVOST

; PHYSICAL UP1: DEVICE OUTPUT
UP1OUT:	LD	A,DEVUP1
	JP	DEVOUT

; PHYSICAL PTR: DEVICE INPUT STATUS
PTRIST:	LD	A,DEVPTR
	JP	DEVIST

; PHYSICAL PTR: DEVICE INPUT
PTRIN:	LD	A,DEVPTR
	JP	DEVIN

; PHYSICAL UR1: DEVICE INPUT STATUS
UR1IST:	LD	A,DEVUR1
	JP	DEVIST

; PHYSICAL UR1: DEVICE INPUT
UR1IN:	LD	A,DEVUR1
	JP	DEVIN

; BIOS SELECT DISK FUNCTION
SELDSK:	LD	HL,0000H
	LD	A,C
	CP	MAXDSK
	RET	NC
	OUT	(DSKNUM),A
	LD	HL,DPBASE
	LD	A,H
	OUT	(DMAHI),A
	LD	A,L
	OUT	(DMALO),A
	LD	A,DSKPB
	OUT	(DSKCTL),A
	RET

; BIOS HOME DISK FUNCTION
HOMTRK:	LD	BC,0000H

; BIOS SET DISK TRACK FUNCTION
SETTRK:	LD	A,B
	OUT	(TRKHI),A
	LD	A,C
	OUT	(TRKLO),A
	RET

; BIOS SET DISK SECTOR FUNCTION
; IN:	BC = SECTOR NUMBER, 0 < NUMBER <= MAXSEC
SETSEC:	DEC	BC
	LD	A,B
	OUT	(SECHI),A
	LD	A,C
	OUT	(SECLO),A
	RET

; BIOS TRANSLATE SECTOR NUMBER FUNCTION
; IN:	BC = SECTOR OFFSET, 0 <= OFFSET < MAXSEC
; IN:	DE = TRANSLATE ARRAY BASE
; OUT:	HL = SECTOR NUMBER, 0 < NUMBER <= MAXSEC
SECXLT:	EX	DE,HL
	ADD	HL,BC
	LD	L,(HL)
	LD	H,0
	RET

; BIOS SET DMA POINTER FUNCTION
SETDMA:	LD	A,B
	OUT	(DMAHI),A
	LD	A,C
	OUT	(DMALO),A
	RET

; BIOS READ DISK SECTOR FUNCTION
RDSEC:	LD	A,DSKRD
	JP	RDWR

; BIOS WRITE DISK SECTOR FUNCTION
WRSEC:	LD	A,DSKWR
RDWR:	OUT	(DSKCTL),A
	IN	A,(DSKCTL)
	AND	DSKERR
	LD	A,1
	RET	NZ
	XOR	A
	RET

; OPEN HOST FILE
; IN: DE = ADDRESS OF CP/M FCB
; OUT: A = 0 IF OK, -1 IF ERROR
OPNFIL:	CALL SETFCB
	LD	A,FILOPN
CTLFIL:	OUT	(FILCTL),A
	IN	A,(FILCTL)
	RET
SETFCB:	LD	A,D
	OUT	(FCBHI),A
	LD	A,E
	OUT	(FCBLO),A
	RET

; CLOSE HOST FILE
; IN: DE = ADDRESS OF CP/M FCB
; OUT: A = 0 IF OK, -1 IF ERROR
CLSFIL:	CALL	SETFCB
	LD	A,FILCLS
	JP	CTLFIL

; DELETE HOST FILE
; IN: DE = ADDRESS OF CP/M FCB
; OUT: A = 0 IF OK, -1 IF ERROR
DELFIL:	CALL	SETFCB
	LD	A,FILDEL
	JP	CTLFIL

; MAKE HOST FILE
; IN: DE = ADDRESS OF CP/M FCB
; OUT: A = 0 IF OK, -1 IF ERROR
MAKFIL:	CALL	SETFCB
	LD	A,FILMAK
	JP	CTLFIL

; READ HOST FILE
; IN: DE = ADDRESS OF CP/M FCB
; OUT: A = 0 IF OK, -1 IF ERROR
RDFIL:	CALL	SETFCB
	LD	A,FILRD
	JP	CTLFIL

; WRITE HOST FILE
; IN: DE = ADDRESS OF CP/M FCB
; OUT: A = 0 IF OK, -1 IF ERROR
WRFIL:	CALL	SETFCB
	LD	A,FILWR
	JP	CTLFIL

; TIME OF DAY
; IN: C = 0 TO GET, -1 TO SET
; IN: HL = ADDRESS OF SET TIME OF DAY
; OUT: HL = ADDRESS OF GET TIME OF DAY
RDTIM:	LD	A,C
	OR	A
	RET	NZ
	LD	HL,TIMBLK+4
	LD	A,TIMS
	CALL	CTLTIM
	DEC	HL
	LD	A,TIMM
	CALL	CTLTIM
	DEC	HL
	LD	A,TIMH
	CALL	CTLTIM
	DEC	HL
	LD	A,TIMDHI
	CALL	CTLTIM
	DEC	HL
	LD	A,TIMDLO
CTLTIM:	OUT	(TIMRD),A
	IN	A,(TIMRD)
	LD	(HL),A
	RET

; DISK PARAMETER TABLE
DPBASE:	DW	XLT,0000H,0000H,0000H,DIRBUF,DPB,CSV,ALV

DIRBUF:	DS	128

DPB:	DS	MAXPB
XLT:	DS	MAXXLT
ALV:	DS	MAXALV
CSV:	DS	MAXCKS

; TIME OF DAY
TIMBLK:	DB	0	; +0: DATE LSB SINCE 1/1/78
	DB	0	; +1: DATE MSB
	DB	0	; +2: HOURS (BCD)
	DB	0	; +3: MINUTES (BCD)
	DB	0	; +4: SECONDS (BCD)

; BIOS STACK
	DW	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
STACK	EQU	$

	END
