	TITLE	"uSim 64K CP/M-IN-ROM BIOS -- i8080 VERSION"

; BIOS64.ASM - uSim 64K CP/M BIOS
; Copyright (C) 2000  Tsurishaddai Williamson, tsuri@earthlink.net
;
; This program is free software; you can redistribute it and/or
; modify it under the terms of the GNU General Public License
; as published by the Free Software Foundation; either version 2
; of the License, or (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program; if not, write to the Free Software
; Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

; NOTE: This must assemble to the same object as BIOS64.Z80.

	.8080

; 63.5K CP/M LOCATIONS
MEMSIZ	EQU	64			; MEMORY SIZE, KILOBYTES
CPMVER	EQU	22			; CP/M VERSION
CCP	EQU	3200H+(MEMSIZ-20)*1024	; CCP BASE ADDRESS
BDOS	EQU	CCP+0800H		; BDOS BASE ADDRESS
BIOS	EQU	CCP+1600H		; BIOS BASE ADDRESS
DATA	EQU	BIOS+(2300H-1F80H)	; BIOS UNINITIALIZED DATA ADDRESS
REBOOT	EQU	0000H			; "JMP REBOOT" TO REBOOT
IOBYTE	EQU	0003H			; ADDRESS OF I/O BYTE VARIABLE
USRDSK	EQU	0004H			; ADDRESS OF USER NUMBER / CURRENT VARIABLE
SYSTEM	EQU	0005H			; "CALL SYSTEM" FOR SYSTEM CALL
USRFCB	EQU	005CH			; ADDRESS OF DEFAULT FILE CONTROL BLOCK
USRBUF	EQU	0080H			; ADDRESS OF DEFAULT I/O BUFFER
USRTPA	EQU	0100H			; ADDRESS OF TRANSIANT PROGRAM AREA

	.SOURCE	"SYSTEM.EQU"

	ORG	BIOS

; JUMP TABLE OF BIOS FUNCTIONS
	JMP	CBOOT	; 0  -- COLD BOOT
WBOOTE:	JMP	WBOOT	; 1  -- WARM BOOT
	JMP	CONIST	; 2  -- CONSOLE INPUT STATUS
	JMP	CONIN	; 3  -- CONSOLE INPUT
	JMP	CONOUT	; 4  -- CONSOLE OUTPUT
	JMP	LSTOUT	; 5  -- LIST OUTPUT
	JMP	PUNOUT	; 6  -- PUNCH OUTPUT
	JMP	RDRIN	; 7  -- READER INPUT
	JMP	HOMTRK	; 8  -- HOME DISK
	JMP	SELDSK	; 9  -- SELECT DISK
	JMP	SETTRK	; 10 -- SET TRACK NUMBER
	JMP	SETSEC	; 11 -- SET SECTOR NUMBER
	JMP	SETDMA	; 12 -- SET DMA ADDRESS
	JMP	RDSEC	; 13 -- READ DISK SECTOR
	JMP	WRSEC	; 14 -- WRITE DISK SECTOR
	JMP	LSTOST	; 15 -- LIST OUTPUT STATUS
	JMP	SECXLT	; 16 -- TRANSLATE SECTOR NUMBER
; EXTRA FUNCTIONS FOR USIM
	JMP	OPNFIL	; 17 -- OPEN HOST FILE
	JMP	CLSFIL	; 18 -- COSE HOST FILE
	JMP	DELFIL	; 19 -- DELETE HOST FILE
	JMP	MAKFIL	; 20 -- MAKE HOST FILE
	JMP	RDFIL	; 21 -- READ HOST FILE
	JMP	WRFIL	; 22 -- WRITE HOST FILE
	JMP	RDTIM	; 23 -- READ TIME OF DAY

; COLD BOOT BANNER DISPLAYS MEMORY SIZE AND CP/M VERSION
BANNER:	DB	13,10
	DB	MEMSIZ / 10 + '0'
	DB	MEMSIZ MOD 10 + '0'
	DB	'K CP/M vers '
	DB	CPMVER / 10 + '0'
	DB	'.'
	DB	CPMVER MOD 10 + '0'
	DB	13,10
	DB	0

; BIOS COLD BOOT FUNCTION
CBOOT:	LXI	SP,STACK
	; SET IOBYTE: LST=LPT, PUN=PTP, RDR=PTR, CON=TTY
	MVI	A,10010100B
	STA	IOBYTE
	; SET CURRENT USER=0 AND DISK=A
	XRA	A
	STA	USRDSK
	; DISPLAY BOOT BANNER
	LXI	B,BANNER
	CALL	PUTS
	; CCP AND BDOS ARE IN PLACE
GOCPM:	; ERROR IF FIRST INSTRUCTION OF CCP IS NOT "JMP"
	LDA	CCP
	CPI	0C3H
	JNZ	ERROR
	; ERROR IF FIRST INSTRUCTION OF BDOS IS NOT "JMP"
	LDA	BDOS+6
	CPI	0C3H
	JNZ	ERROR
	; PREPARE DEFAULT DMA POINTER
	LXI	B,USRBUF
	CALL	SETDMA
	; PREPARE "REBOOT: JMP WBOOTE"
	; PREPARE "SYSTEM: JMP BDOS+6"
	MVI	A,0C3H
	STA	REBOOT
	STA	SYSTEM
	LXI	H,WBOOTE
	SHLD	REBOOT+1
	LXI	H,BDOS+6
	SHLD	SYSTEM+1
	; CCP IN: C = USRDSK
	LDA	USRDSK
	MOV	C,A
	; ENABLE INTERRUPTS AND ENTER CCP
	EI
	JMP	CCP

; RETRY THE WARM BOOT IF THERE WAS AN ERROR
ERRMSG:	DB	13,10,'?SYSTEM',13,10,0
ERROR:	LXI	B,ERRMSG
	CALL	PUTS
	CALL	CONIN

; BIOS WARM BOOT FUNCTION
WBOOT:	LXI	SP,STACK
	; COPY CCP+BDOS INTO MEMORY
	XRA	A
	STA	CCP
	STA	BDOS+6
	; LOAD FROM ROM
	MVI	A, MINROM + 3
	OUT	BANK0
	LXI	B,CCP - (BNKSIZ * 3)
	LXI	D,CCP
COPY:	LDAX	B
	STAX	D
	INX	B
	INX	D
	MOV	A,D
	ORA	E
	JNZ	COPY
	MVI	A,MINRAM
	OUT	BANK0
	; ENTER CP/M
	JMP	GOCPM

; PRINT A STRING
; IN: BC = ADDRESS OF ZERO-TERMINATED STRING
PUTS:	MVI	A,DEVTTY
	OUT	DEVCTL
	LDAX	B
	ORA	A
	RZ
	INX	B
	OUT	DEVDAT
	JMP	PUTS

; LOGICAL CON: DEVICE INPUT STATUS VIA IOBYTE
CONIST:	LDA	IOBYTE
        ANI	00000011B
        JZ	TTYIST
        CPI	00000001B
        JZ	CRTIST
        CPI	00000010B
        JZ	RDRIST

; PHYSICAL UC1: DEVICE INPUT STATUS
UC1IST:	MVI	A,DEVUC1
	JMP	DEVIST

; LOGICAL CON: DEVICE INPUT VIA IOBYTE
CONIN:	CAll	CONIST
	JZ	CONIN
	LDA	IOBYTE
        ANI	00000011B
        JZ	TTYIN
        CPI	00000001B
        JZ	CRTIN
        CPI	00000010B
        JZ	RDRIN

; PHYSICAL UC1: DEVICE INPUT
UC1IN:	MVI	A,DEVUC1
	JMP	DEVIN

; LOGICAL CON: DEVICE OUTPUT STATUS VIA IOBYTE
CONOST: LDA	IOBYTE
        ANI	00000011B
        JZ	TTYOST
        CPI	00000001B
        JZ	CRTOST
        CPI	00000010B
        JZ	LPTOST

; PHYSICAL UC1: DEVICE OUTPUT STATUS
UC1OST:	MVI	A,DEVUC1
	JMP	DEVOST

; LOGICAL CON: DEVICE OUTPUT VIA IOBYTE
CONOUT:	CALL	CONOST
	JZ	CONOUT
	LDA	IOBYTE
        ANI	00000011B
        JZ	TTYOUT
        CPI	00000001B
        JZ	CRTOUT
        CPI	00000010B
        JZ	LPTOUT

; PHYSICAL UC1: DEVICE OUTPUT
UC1OUT:	MVI	A,DEVUC1
	JMP	DEVOUT

; LOGICAL LST: DEVICE OUTPUT VIA IOBYTE
LSTOUT:	CALL	LSTOST
	JZ	LSTOUT
	LDA	IOBYTE
        ANI	11000000B
        JZ	TTYOUT
        CPI	01000000B
        JZ	CRTOUT
        CPI	10000000B
        JZ	LPTOUT

; PHYSICAL UL1: DEVICE OUTPUT
UL1OUT:	MVI	A,DEVUL1
	JMP	DEVOUT

; LOGICAL LST: DEVICE OUTPUT STATUS VIA IOBYTE
LSTOST:	LDA	IOBYTE
        ANI	11000000B
        JZ	TTYOST
        CPI	01000000B
        JZ	CRTOST
        CPI	10000000B
        JZ	LPTOST

; PHYSICAL UL1: DEVICE OUTPUT STATUS
UL1OST:	MVI	A,DEVUL1
	JMP	DEVOST

; LOGICAL PUN: DEVICE OUTPUT STATUS VIA IOBYTE
PUNOST:	LDA	IOBYTE
        ANI	00110000B
        JZ	TTYOST
        CPI	00010000B
        JZ	PTPOST
        CPI	00100000B
        JZ	UP1OST

; PHYSICAL UP2: DEVICE OUTPUT STATUS
UP2OST:	MVI	A,DEVUP2
	JMP	DEVOST

; LOGICAL PUN: DEVICE OUTPUT VIA IOBYTE
PUNOUT:	CALL	PUNOST
	JZ	PUNOUT
	LDA	IOBYTE
        ANI	00110000B
        JZ	TTYOUT
        CPI	00010000B
        JZ	PTPOUT
        CPI	00100000B
        JZ	UP1OUT

; PHYSICAL UP2: DEVICE OUTPUT
UP2OUT:	MVI	A,DEVUP2
	JMP	DEVOUT

; LOGICAL RDR: DEVICE INPUT STATUS VIA IOBYTE
RDRIST:	LDA	IOBYTE
        ANI	00001100B
        JZ	TTYIST
        CPI	00000100B
        JZ	PTRIST
        CPI	00001000B
        JZ	UR1IST

; PHYSICAL UR2: DEVICE INPUT STATUS
UR2IST:	MVI	A,DEVUR2
	JMP	DEVIST

; LOGICAL RDR: DEVICE INPUT VIA IOBYTE
RDRIN:	CALL	RDRIST
	JZ	RDRIN
	LDA	IOBYTE
        ANI	00001100B
        JZ	TTYIN
        CPI	00000100B
        JZ	PTRIN
        CPI	00001000B
        JZ	UR1IN

; PHYSICAL UR2: DEVICE INPUT
UR2IN:	MVI	A,DEVUR2
	JMP	DEVIN

; PHYSICAL TTY: DEVICE INPUT STATUS
TTYIST:	MVI	A,DEVTTY

; CHARACTER DEVICE INPUT STATUS
DEVIST:	OUT	DEVCTL
	IN	DEVCTL
	ANI	DEVRD

; RETURN STATUS -1 IF READY, 0 IF NOT
RETST:	ORA	A
	RZ
	MVI	A,255
	RET

; PHYSICAL TTY: DEVICE INPUT
TTYIN:	MVI	A,DEVTTY

; CHARACTER DEVICE INPUT
DEVIN:	OUT	DEVCTL
	IN	DEVDAT
	RET

; PHYSICAL TTY: DEVICE OUTPUT STATUS
TTYOST:	MVI	A,DEVTTY

; CHARACTER DEVICE OUTPUT STATUS
DEVOST:	OUT	DEVCTL
	IN	DEVCTL
	ANI	DEVWR
	JMP	RETST

; PHYSICAL TTY: DEVICE OUTPUT
TTYOUT:	MVI	A,DEVTTY

; CHARACTER DEVICE OUTPUT
DEVOUT:	OUT	DEVCTL
	MOV	A,C
	OUT	DEVDAT
	RET

; PHYSICAL CRT: DEVICE INPUT STATUS
CRTIST:	MVI	A,DEVCRT
	JMP	DEVIST

; PHYSICAL CRT: DEVICE INPUT
CRTIN:	MVI	A,DEVCRT
	JMP	DEVIN

; PHYSICAL CRT: DEVICE OUTPUT STATUS
CRTOST:	MVI	A,DEVCRT
	JMP	DEVOST

; PHYSICAL CRT: DEVICE OUTPUT
CRTOUT:	MVI	A,DEVCRT
	JMP	DEVOUT

; PHYSICAL LPT: DEVICE OUTPUT STATUS
LPTOST:	MVI	A,DEVLPT
	JMP	DEVOST

; PHYSICAL LPT: DEVICE OUTPUT
LPTOUT:	MVI	A,DEVLPT
	JMP	DEVOUT

; PHYSICAL PTP: DEVICE OUTPUT STATUS
PTPOST:	MVI	A,DEVPTP
	JMP	DEVOST

; PHYSICAL PTP: DEVICE OUTPUT
PTPOUT:	MVI	A,DEVPTP
	JMP	DEVOUT

; PHYSICAL UP1: DEVICE OUTPUT STATUS
UP1OST:	MVI	A,DEVUP1
	JMP	DEVOST

; PHYSICAL UP1: DEVICE OUTPUT
UP1OUT:	MVI	A,DEVUP1
	JMP	DEVOUT

; PHYSICAL PTR: DEVICE INPUT STATUS
PTRIST:	MVI	A,DEVPTR
	JMP	DEVIST

; PHYSICAL PTR: DEVICE INPUT
PTRIN:	MVI	A,DEVPTR
	JMP	DEVIN

; PHYSICAL UR1: DEVICE INPUT STATUS
UR1IST:	MVI	A,DEVUR1
	JMP	DEVIST

; PHYSICAL UR1: DEVICE INPUT
UR1IN:	MVI	A,DEVUR1
	JMP	DEVIN

; BIOS SELECT DISK FUNCTION
SELDSK:	LXI	H,0000H
	MOV	A,C
	CPI	MAXDSK
	RNC
	OUT	DSKNUM
	LXI	H,DPBASE
	MOV	A,H
	OUT	DMAHI
	MOV	A,L
	OUT	DMALO
	MVI	A,DSKPB
	OUT	DSKCTL
	RET

; BIOS HOME DISK FUNCTION
HOMTRK:	LXI	B,0000H

; BIOS SET DISK TRACK FUNCTION
SETTRK:	MOV	A,B
	OUT	TRKHI
	MOV	A,C
	OUT	TRKLO
	RET

; BIOS SET DISK SECTOR FUNCTION
; IN:	BC = SECTOR NUMBER, 0 < NUMBER <= MAXSEC
SETSEC:	DCX	B
	MOV	A,B
	OUT	SECHI
	MOV	A,C
	OUT	SECLO
	RET

; BIOS TRANSLATE SECTOR NUMBER FUNCTION
; IN:	BC = SECTOR OFFSET, 0 <= OFFSET < MAXSEC
; IN:	DE = TRANSLATE ARRAY BASE
; OUT:	HL = SECTOR NUMBER, 0 < NUMBER <= MAXSEC
SECXLT:	XCHG
	DAD	B
	MOV	L,M
	MVI	H,0
	RET

; BIOS SET DMA POINTER FUNCTION
SETDMA:	MOV	A,B
	OUT	DMAHI
	MOV	A,C
	OUT	DMALO
	RET

; BIOS READ DISK SECTOR FUNCTION
RDSEC:	MVI	A,DSKRD
	JMP	RDWR

; BIOS WRITE DISK SECTOR FUNCTION
WRSEC:	MVI	A,DSKWR
RDWR:	OUT	DSKCTL
	IN	DSKCTL
	ANI	DSKERR
	MVI	A,1
	RNZ
	XRA	A
	RET

; OPEN HOST FILE
; IN: DE = ADDRESS OF CP/M FCB
; OUT: A = 0 IF OK, -1 IF ERROR
OPNFIL:	CALL SETFCB
	MVI	A,FILOPN
CTLFIL:	OUT	FILCTL
	IN	FILCTL
	RET
SETFCB:	MOV	A,D
	OUT	FCBHI
	MOV	A,E
	OUT	FCBLO
	RET

; CLOSE HOST FILE
; IN: DE = ADDRESS OF CP/M FCB
; OUT: A = 0 IF OK, -1 IF ERROR
CLSFIL:	CALL	SETFCB
	MVI	A,FILCLS
	JMP	CTLFIL

; DELETE HOST FILE
; IN: DE = ADDRESS OF CP/M FCB
; OUT: A = 0 IF OK, -1 IF ERROR
DELFIL:	CALL	SETFCB
	MVI	A,FILDEL
	JMP	CTLFIL

; MAKE HOST FILE
; IN: DE = ADDRESS OF CP/M FCB
; OUT: A = 0 IF OK, -1 IF ERROR
MAKFIL:	CALL	SETFCB
	MVI	A,FILMAK
	JMP	CTLFIL

; READ HOST FILE
; IN: DE = ADDRESS OF CP/M FCB
; OUT: A = 0 IF OK, -1 IF ERROR
RDFIL:	CALL	SETFCB
	MVI	A,FILRD
	JMP	CTLFIL

; WRITE HOST FILE
; IN: DE = ADDRESS OF CP/M FCB
; OUT: A = 0 IF OK, -1 IF ERROR
WRFIL:	CALL	SETFCB
	MVI	A,FILWR
	JMP	CTLFIL

; TIME OF DAY
; IN: C = 0 TO GET, -1 TO SET
; IN: HL = ADDRESS OF SET TIME OF DAY
; OUT: HL = ADDRESS OF GET TIME OF DAY
RDTIM:	MOV	A,C
	ORA	A
	RNZ
	LXI	H,TIMBLK+4
	MVI	A,TIMS
	CALL	CTLTIM
	DCX	H
	MVI	A,TIMM
	CALL	CTLTIM
	DCX	H
	MVI	A,TIMH
	CALL	CTLTIM
	DCX	H
	MVI	A,TIMDHI
	CALL	CTLTIM
	DCX	H
	MVI	A,TIMDLO
CTLTIM:	OUT	TIMRD
	IN	TIMRD
	MOV	M,A
	RET

; DISK PARAMETER TABLE
DPBASE:	DW	XLT,0000H,0000H,0000H,DIRBUF,DPB,CSV,ALV

DIRBUF:	DS	128

DPB:	DS	MAXPB
XLT:	DS	MAXXLT
ALV:	DS	MAXALV
CSV:	DS	MAXCKS

; TIME OF DAY
TIMBLK:	DB	0	; +0: DATE LSB SINCE 1/1/78
	DB	0	; +1: DATE MSB
	DB	0	; +2: HOURS (BCD)
	DB	0	; +3: MINUTES (BCD)
	DB	0	; +4: SECONDS (BCD)

; BIOS STACK
	DW	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
STACK	EQU	$

	END
